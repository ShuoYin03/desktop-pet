# Desktop Pet Architecture Overview

## Runtime layout
- **Electron main process (`apps/desktop/src/main`)** keeps the transparent window alive and loads the renderer bundle. It stays intentionally thin while we flesh out window management features (e.g. pin-to-top, drag regions).
- **Preload bridge (`apps/desktop/src/preload`)** owns the `PetEngine` instance and exposes a typed API through `contextBridge`. All renderer <-> native interactions go through this layer so we can enforce validation and later plug in file-system, audio and ML helpers.
- **Renderer (`apps/desktop/src/renderer`)** is a React UI that subscribes to engine snapshots. For the MVP it displays an SVG-based mock pet, offers state buttons, and requests the `chasing` animation while the user moves their mouse over the window.

## Pet engine state machine
- `packages/engine` provides a deterministic state machine that:
  - stores `StateDefinition` objects with frame sequences and optional transitions;
  - ticks on a 60 FPS interval (`setInterval` with 16 ms cadence);
  - emits immutable `EngineSnapshot`s to any subscribed listener.
- States can define automatic transitions (`type: "auto"`) that trigger after `minDurationMs` elapses. Manual transitions are requested via `setState` and validated against the known state map.
- The preload layer currently initialises the engine with a `sampleConfig` that renders placeholder SVG textures via data URIs. This keeps the renderer logic and animation timing ready while we wait for real sprite sheets.

## Asset pipeline (first pass)
- All raw uploads and generated outputs live inside `assets/`.
- Organise by media type first, then by pet identifier, e.g.
  - `assets/textures/<petId>/raw/` for user uploads;
  - `assets/textures/<petId>/processed/` for cleaned sprite frames generated by our tooling;
  - `assets/audio/<petId>/purr/` for rumbling tracks plus metadata.
- Automation scripts (e.g. Python notebooks) should write intermediate artefacts to `assets/cache/` so we can `.gitignore` large generated data but keep reproducible recipes.
- The renderer consumes packed sprite sheets or data URIs emitted by a forthcoming build step. Until then, `sampleConfig` documents the schema we expect those tools to produce.

## Next steps
1. Replace the placeholder SVG frames with pipeline-generated textures and wire the loader to disk access (behind preload APIs).
2. Introduce audio playback hooks for purring and contextual sound effects.
3. Expand the state machine to support blended animations (e.g. overlays for blinking) and parameterised transitions (cursor distance, feeding timer, etc.).
